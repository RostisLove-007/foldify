# Foldify - Редактор паттернов складок оригами

## Описание проекта

**Foldify** — это интерактивное графическое приложение для проектирования и анализа паттернов складок оригами (crease patterns). Программа позволяет художникам и исследователям создавать сложные складочные диаграммы с использованием специализированных инструментов геометрического проектирования, проверять корректность паттернов и визуализировать результаты.

Приложение разработано на **wxPython** и предоставляет полнофункциональный интерфейс для работы со складками горного типа (mountain fold), долинного типа (valley fold) и вспомогательными линиями.

---

## Основной функционал

### Основные возможности

- **Редактирование паттернов складок**
  - Рисование линий складок (горные и долинные складки)
  - Рисование вспомогательных линий для построения

- **Геометрические инструменты**
  - Деление угла пополам
  - Построение перпендикуляров
  - Поиск инцентра треугольника

- **Динамическая сетка**
  - Регулируемая сетка с настраиваемым количеством делений
  - Привязка точек к сетке для точности
  - Относительная и абсолютная система координат

- **Проверка паттернов**
  - Валидация корректности паттерна складок
  - Обнаружение ошибок при складывании
  - Визуализация проблемных областей

- **Сохранение и загрузка**
  - Экспорт паттернов в JSON-формате
  - Восстановление сохраненного состояния

- **Визуализация**
  - Отображение сложенной модели в случае правильно нарисованного узора складок
  - Отображение узора складок с помеченными красным цветом узлами, которые не прошли проверку правил Кавасаки

---

## Установка

### Требования

- Python 3.8 или выше
- wxPython 4.1+

### Шаги установки

#### 1. Клонирование репозитория

```bash
git clone <https://github.com/RostisLove-007/foldify.git>
cd foldify
```

#### 2. Создание виртуального окружения (рекомендуется)

```bash
python -m venv venv
source venv/bin/activate  # На Windows: venv\Scripts\activate
```

#### 3. Установка зависимостей

```bash
pip install -r requirements.txt
```

#### 4. Запуск приложения

```bash
python foldify.py
```

---

## Основные сценарии использования

### Сценарий 1: Создание простого паттерна складок

#### Шаг 1: Запуск приложения

При запуске приложения отобразится главное окно с белым полотном и сеткой.

![Главное окно Foldify](src/screenshots/01_main_window.png)
*Главное окно приложения с пустым полотном и управляющей панелью*

#### Шаг 2: Установка режима рисования

В левой панели выберите тип складки:
- **Mountain Fold** (Горная складка) - для гор, будет красного цвета
- **Valley Fold** (Долинная складка) - для долин, будет синего цвета
- **Auxiliary Line** (Вспомогательная линия) - для построения, серого цвета

```python
# Пример программного обращения:
app = wx.App()
frame = Foldify(None, "Foldify")
# Приложение будет ждать пользовательского ввода
app.MainLoop()
```

#### Шаг 3: Рисование первой линии

1. Кликните в область полотна, чтобы установить первую точку
2. Наведите мышь на нужное место для второй точки
3. Кликните для завершения линии

![Рисование линии](src/screenshots/02_drawing_line.png)
*Процесс рисования линии с предпросмотром (пунктирная линия)*

#### Шаг 4: Продолжение работы

Повторяйте шаги 2-3 для создания сложного паттерна:

```
Пример простого паттерна:
1. Горная складка (0, 0) → (1, 1)
2. Долинная складка (0, 1) → (0.5, 0.5)
3. Горная складка (0.5, 0.5) → (1, 1)
```

![Готовый паттерн](src/screenshots/03_completed_pattern.png)
*Завершённый простой паттерн складок с тремя линиями*

---

### Сценарий 2: Использование геометрических инструментов

#### Инструмент 1: Деление угла пополам (Биссектриса)

Строит биссектрису угла, образованного тремя точками:

1. Переключитесь в режим **Bisector** (Биссектриса)
2. Выберите первую точку угла
3. Выберите вершину угла (центральная точка)
4. Выберите третью точку угла
5. Выберите ребро (линию), до которой будет продолжена биссектриса

![Биссектриса](src/screenshots/04_bisector_tool.png)
*Использование инструмента биссектрисы для деления угла пополам*

```python
# Принцип работы биссектрисы:
# Для трёх точек p1, v (вершина), p2:
# 1. Вычисляются единичные векторы от v к p1 и от v к p2
# 2. Биссектриса направлена по сумме этих единичных векторов
# 3. Линия продолжается до пересечения с выбранным ребром

# Пример работы с векторами:
v1 = (p1[0] - v[0], p1[1] - v[1])
v2 = (p2[0] - v[0], p2[1] - v[1])
unit1 = v1 / |v1|
unit2 = v2 / |v2|
bisector_direction = normalize(unit1 + unit2)
```

#### Инструмент 2: Перпендикуляр

Строит перпендикуляр из точки на линию:

1. Переключитесь в режим **Perpendicular** (Перпендикуляр)
2. Кликните на исходную точку
3. Выберите линию, к которой нужен перпендикуляр
4. Система автоматически найдёт точку пересечения перпендикуляра с линией

![Перпендикуляр](src/screenshots/05_perpendicular_tool.png)
*Построение перпендикуляра из точки на линию*

```python
# Функция поиска перпендикуляра:
def point_to_line_distance(p, a, b):
    """
    Вычислить минимальное расстояние от точки до отрезка
    и найти точку пересечения перпендикуляра
    """
```

#### Инструмент 3: Инцентр треугольника

Находит центр вписанной окружности для трёх выбранных точек:

1. Переключитесь в режим **Incenter** (Инцентр)
2. Выберите три вершины треугольника
3. Система найдёт инцентр и покажет его центром и линиями к вершинам

![Инцентр](src/screenshots/06_incenter_tool.png)
*Нахождение инцентра треугольника с визуализацией вписанной окружности*

```python
def triangle_incenter(a, b, c):
    """
    Вычислить инцентр (центр вписанной окружности) треугольника
    
    Формула:
        I = (a*|BC| + b*|CA| + c*|AB|) / (|AB| + |BC| + |CA|)
    где |BC|, |CA|, |AB| - длины сторон
    """
```

---

### Сценарий 3: Настройка сетки

Сетка помогает позиционировать точки с высокой точностью:

#### Изменение количества делений

1. Найдите поле **Размер сетки** в левой панели
2. Введите число от 1 до 100 (количество делений на одной стороне квадрата)
3. Сетка пересчитается автоматически

![Сетка](src/screenshots/07_grid_settings.png)
*Панель настройки сетки с различными уровнями детализации*

#### Относительные координаты

При наведении мыши на полотно отображаются координаты в диапазоне **(0.0, 0.0)** до **(1.0, 1.0)**:

![Координаты](src/screenshots/08_coordinates_display.png)
*Отображение координат под курсором мыши в формате (x, y)*

---

### Сценарий 4: Сохранение и загрузка паттерна

#### Сохранение паттерна

1. Нажмите **Файл** → **Экспорт** в меню приложения
2. Выберите место для сохранения
3. Файл будет сохранён в JSON-формате

```python
# Структура сохраняемого JSON-файла:
{
  "lines": [
    {
      "p0": {"x": 0.0, "y": 0.0},
      "p1": {"x": 1.0, "y": 1.0},
      "type": 1  # 1=MOUNTAIN, 2=VALLEY, 3=AUX, 4=CUT
    }
  ],
  "vertices": [
    {"p": {"x": 0.0, "y": 0.0}}
  ]
}
```
![Диалог экспорта](src/screenshots/09_export_dialog.png)

#### Загрузка паттерна

1. Нажмите **Файл** → **Импорт** в меню приложения
2. Выберите JSON-файл с сохранённым паттерном
3. Паттерн загрузится в редактор

![Диалог импорта](src/screenshots/10_import_dialog.png)
*Диалог сохранения паттерна в JSON-формате*

---

### Сценарий 5: Проверка корректности паттерна

После создания паттерна можно проверить его корректность:

1. Нажмите на **Проверить складывание** 
2. Система проанализирует паттерн на ошибки
3. Если ошибок нет, откроется окно с визуализацией успешного паттерна, а если ошибки есть, то программа выделит узлы в которых есть нарушение правил Кавасаки

![Валидация_успех](src/screenshots/11_validation_window_succes.png)
*Окно успешной проверки паттерна*

![Валидация_ошибка](src/screenshots/12_validation_window_error.png)
*Окно проверки паттерна в котором обнаружены ошибки*

---

### Сценарий 6: Получение сложенной модели

После проверки паттерна, в случае если в нем нет ошибок, его можно сложить

1. Нажмите на **Сложить** 
2. Система проанализирует паттерн на ошибки
3. Если ошибок нет, откроется окно сложенной модели, а если ошибки есть, то программа выделит узлы в которых есть нарушение правил Кавасаки

![Сложение](src/screenshots/13_display_folded_model.png)
*Окно отображения сложенной модели*

---

## Архитектура программы (для программистов)

### Основные классы

#### 1. `Point2D` - Двумерная точка

```python
@dataclass(frozen=True, eq=True)
class Point2D:
    """Двумерная точка с поддержкой векторных операций"""
    x: float
    y: float
    
    def __add__(self, other: "Point2D") -> "Point2D":
        """Сложение векторов"""
    
    def distance_to(self, other: "Point2D") -> float:
        """Расстояние до другой точки"""
    
    def normalized(self) -> "Point2D":
        """Нормализованный вектор"""
```

#### 2. `Line` - Линия складки

```python
@dataclass
class Line:
    """Представляет линию складки в паттерне"""
    p0: Point2D  # Начало линии
    p1: Point2D  # Конец линии
    type: LineType  # MOUNTAIN, VALLEY, AUX, CUT
    
    def midpoint(self) -> Point2D:
        """Середина линии"""
    
    def length(self) -> float:
        """Длина линии"""
```

#### 3. `CreasePattern` - Паттерн складок

```python
class CreasePattern:
    """Основной класс, представляющий паттерн складок"""
    
    def __init__(self):
        self.lines: List[Line] = []
        self.vertices: List[Vertex] = []
    
    def add_line(self, p0: Point2D, p1: Point2D, type: LineType) -> bool:
        """Добавить линию в паттерн"""
    
    def validate(self) -> bool:
        """Проверить корректность паттерна"""
    
    def get_intersections(self) -> List[Point2D]:
        """Найти все пересечения линий"""
```

#### 4. `Foldify` - Главное окно приложения

```python
class Foldify(wx.Frame):
    """Главное окно графического редактора"""
    
    def __init__(self, parent, title):
        super().__init__(parent, title=title, size=(1400, 900))
        
    def on_paint(self, event):
        """Обработчик события рисования"""
    
    def on_mouse_motion(self, event):
        """Обработчик движения мыши"""
    
    def on_mouse_left_down(self, event):
        """Обработчик клика левой кнопкой"""
```

### Ключевые функции обработки геометрии

```python
# Поиск пересечения двух линий
def line_intersection_rel(line1, line2) -> Optional[Tuple[float, float]]:
    """Найти пересечение двух отрезков прямых"""

# Расстояние от точки до линии
def point_to_line_distance(p, a, b) -> float:
    """Вычислить минимальное расстояние"""

# Отражение точки относительно линии (вспомогательная функция)
def reflect_point_over_line(p, a, b) -> Tuple[float, float]:
    """Отразить точку p относительно линии (a, b)"""

# Инцентр треугольника
def triangle_incenter(a, b, c) -> Tuple[float, float]:
    """Найти центр вписанной окружности"""
```

### Система координат

Программа использует две системы координат:

1. **Относительные координаты (0.0 - 1.0)**
   - Независимы от размера окна
   - Используются для сохранения данных
   - Диапазон: (0, 0) - нижний левый, (1, 1) - верхний правый

2. **Абсолютные координаты (экранные пиксели)**
   - Зависят от размера окна
   - Используются для отрисовки
   - Преобразование: `abs = rel * scale + offset`

```python
def rel_to_abs(self, rel_point: Tuple[float, float]) -> Optional[Tuple[float, float]]:
    """Преобразовать из относительных в абсолютные координаты"""

def abs_to_rel(self, abs_point: Tuple[float, float]) -> Optional[Tuple[float, float]]:
    """Преобразовать из абсолютных в относительные координаты"""
```

### Режимы работы

Приложение поддерживает несколько режимов:

```python
MODE_INPUT = 0      # Режим рисования линий
MODE_EDIT = 1       # Режим редактирования

SUBMODE_SEGMENT = 0     # Рисование отрезков
SUBMODE_BISECTOR = 1    # Деление угла пополам
SUBMODE_INCENTER = 2    # Инцентр треугольника
SUBMODE_PERP = 3        # Перпендикуляр
```

### Типы линий

```python
class LineType(Enum):
    MOUNTAIN = 1  # Горная складка (красная)
    VALLEY = 2    # Долинная складка (синяя)
    AUX = 3       # Вспомогательная линия (серая)
    CUT = 4       # Линия границы
    NONE = 0      # Отсутствие типа
```

---

## Примеры кода для разработчиков

### Пример 1: Создание паттерна программно

```python
from foldify import CreasePattern, Point2D, LineType

# Создать паттерн
pattern = CreasePattern()

# Добавить горную складку
p0 = Point2D(0.0, 0.0)
p1 = Point2D(1.0, 1.0)
pattern.add_line(p0, p1, LineType.MOUNTAIN)

# Добавить долинную складку
p2 = Point2D(0.0, 1.0)
p3 = Point2D(1.0, 0.0)
pattern.add_line(p2, p3, LineType.VALLEY)

# Проверить корректность
if pattern.validate():
    print("Паттерн валидный!")
```

### Пример 2: Работа с геометрией

```python
from foldify import (
    triangle_incenter,
    line_intersection_rel
)

# Поиск инцентра треугольника
a = (0.0, 0.0)
b = (1.0, 0.0)
c = (0.5, 1.0)
center = triangle_incenter(a, b, c)
print(f"Инцентр: {center}")

# Пересечение двух линий
line1 = ((0.0, 0.0), (1.0, 1.0))
line2 = ((0.0, 1.0), (1.0, 0.0))
intersection = line_intersection_rel(line1, line2)
print(f"Пересечение: {intersection}")
```

### Пример 3: Расширение приложения

Для добавления нового инструмента геометрии:

```python
class Foldify(wx.Frame):
    # Добавить новый SUBMODE
    SUBMODE_CUSTOM = 4
    
    def on_custom_tool(self):
        """Обработчик нового инструмента"""
        self.submode = self.SUBMODE_CUSTOM
    
    def on_mouse_left_down(self, event):
        # В существующем обработчике добавить:
        if self.submode == self.SUBMODE_CUSTOM:
            # Ваша логика здесь
            pass
```

---

## Горячие клавиши

| Клавиша | Действие |
|---------|----------|
| `Ctrl+S` | Сохранить паттерн |
| `Ctrl+O` | Открыть паттерн |
| `Ctrl+Z` | Отменить последнее действие |

---

## Известные ограничения и особенности

1. **Точность**: Использует float64, рекомендуется для паттернов с делениями до 64
2. **Производительность**: При более чем 5 линий может замедлиться отрисовка и точность отображаемой сложенной модели
3. **Валидация**: Проверяет геометрическую корректность, но не физическую складываемость
